{
  "pageId": "a2178d0a-2210-4f9b-9dfc-7fca9a317c9a",
  "lastEditedAt": "2023-06-03T11:23:00.000Z",
  "slug": "translation-view-children-and-content-children-in-angular-2",
  "properties": {
    "title": "[日本語訳] ViewChildren and ContentChildren in Angular 2",
    "date": "2016-04-16T00:00:00.000Z",
    "tags": ["tech", "Angular", "translation"]
  },
  "content": [
    {
      "type": "bulleted_list",
      "items": [
        {
          "type": "bulleted_list_item",
          "text": [
            {
              "type": "text",
              "text": "Original: ",
              "annotations": {}
            },
            {
              "type": "text",
              "text": "ViewChildren and ContentChildren in Angular 2",
              "href": "http://blog.mgechev.com/2016/01/23/angular2-viewchildren-contentchildren-difference-viewproviders/",
              "annotations": {}
            }
          ],
          "children": []
        },
        {
          "type": "bulleted_list_item",
          "text": [
            {
              "type": "text",
              "text": "Written by: ",
              "annotations": {}
            },
            {
              "type": "text",
              "text": "Minko Gechev",
              "href": "http://twitter.com/mgechev",
              "annotations": {}
            }
          ],
          "children": []
        },
        {
          "type": "bulleted_list_item",
          "text": [
            {
              "type": "text",
              "text": "Translated at: 04/16/2016",
              "annotations": {}
            }
          ],
          "children": []
        }
      ]
    },
    {
      "type": "divider"
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "この記事ではAngular 2の ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "View Children",
          "annotations": {
            "bold": true
          }
        },
        {
          "type": "text",
          "text": " と ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "Content Children",
          "annotations": {
            "bold": true
          }
        },
        {
          "type": "text",
          "text": " の違いについて解説します。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "それぞれの子要素に対して、親コンポーネントからどのようにアクセスするのかを理解し、 そして",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "@Component",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": "デコレータの ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "providers",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " と ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "viewProviders",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " の2つのプロパティの違いについても述べていきます。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "heading",
      "level": 2,
      "text": [
        {
          "type": "text",
          "text": "プリミティブの合成",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "まず初めに、Angular 2のコンポーネントとディレクティブの関係についておさらいしましょう。 ユーザーインタフェースを作るのに一般的なデザインは",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "Compositeパターン",
          "href": "https://ja.wikipedia.org/wiki/Composite_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "です。 このデザインパターンは異なるプリミティブを合成し、1つのインスタンスとして同じ方法で扱えるようにします。 関数型プラグラミングの世界では関数を合成することもできます。例えば次のように",
          "annotations": {}
        }
      ]
    },
    {
      "type": "code",
      "language": "",
      "filename": "",
      "text": "map ((*2).(+1)) [1, 2, 3]\n-- [4,6,8]"
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "このHaskellのコードは",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "(*2)",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": "と",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "(+1)",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": "という2つの関数を合成し、 リスト内の各アイテム",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "n",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": "に対して",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "n -> + 1 -> * 2",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": "という流れで適用されます。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "heading",
      "level": 2,
      "text": [
        {
          "type": "text",
          "text": "UIにおける合成",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "ユーザーインタフェースにおいても同じことがいえます。 コンポーネントを1つの関数として見てみましょう。 各関数は順序に従って合成可能であり、結果として複雑なコンポーネントを作ることができます。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "この構造は次の図で表すことができます。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "image",
      "url": "http://blog.mgechev.com/images/component-directive-angular2.png",
      "caption": ""
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "この図には2つの要素があります。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "bulleted_list",
      "items": [
        {
          "type": "bulleted_list_item",
          "text": [
            {
              "type": "text",
              "text": "Directive: ロジックを持った要素ですが、構造は内包していません。",
              "annotations": {}
            }
          ],
          "children": []
        },
        {
          "type": "bulleted_list_item",
          "text": [
            {
              "type": "text",
              "text": "Component: 1つの要素であり、1つのディレクティブでもあります。そして複数のディレクティブを内包しています。(コンポーネントを内包することもできます)",
              "annotations": {}
            }
          ],
          "children": []
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "これはつまり、次のような構造を作ることができるということです。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "image",
      "url": "http://blog.mgechev.com/images/component-tree-angular2.png",
      "caption": ""
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "上の図を見ると、コンポーネントとディレクティブによる階層構造ができていることがわかります。 末端の要素はディレクティブか、ディレクティブを内包しないコンポーネントのどちらかになります。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "heading",
      "level": 2,
      "text": [
        {
          "type": "text",
          "text": "Angular 2におけるコンポーネントの合成",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "さて、そろそろAngular 2の具体的な話をしましょう。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "これから説明することをわかりやすくするために、簡単なアプリケーションを作っていきます。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "code",
      "language": "",
      "filename": "",
      "text": "// ...@Component({  selector: 'todo-app',  providers: [TodoList],  directives: [TodoCmp, TodoInputCmp],  template: `    <section>      Add todo:      <todo-input (onTodo)=\"addTodo($event)\"></todo-input>    </section>    <section>      <h4 *ngIf=\"todos.getAll().length\">Todo list</h4>      <todo *ngFor=\"var todo of todos.getAll()\" [todo]=\"todo\">      </todo>    </section>    <ng-content select=\"footer\"></ng-content>  `})class TodoAppCmp {  constructor(private todos: TodoList) {}  addTodo(todo) {    this.todos.add(todo);  }}// ..."
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "これは ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "Yet another MV* todo application",
          "annotations": {
            "italic": true
          }
        },
        {
          "type": "text",
          "text": " です. (訳注：アプリケーションの名前なのでそのまま残しています。)",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "上では ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "todo-app",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " というセレクタで、テンプレートを持ったコンポーネントを定義しています。 そして、子要素として使われるディレクティブのセットを定義しています。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "このコンポーネントは次のように使われます。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "code",
      "language": "html",
      "filename": "",
      "text": "<todo-app></todo-app>"
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "これは標準的なXMLの構文なので、 開始タグと終了タグの間に任意のcontentを挿入することができます。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "code",
      "language": "html",
      "filename": "",
      "text": "<todo-app>  <footer>    Yet another todo app!  </footer></todo-app>"
    },
    {
      "type": "heading",
      "level": 2,
      "text": [
        {
          "type": "text",
          "text": "ng-content",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " による基本的なcontentの表示",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "ここで ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "todo-app",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " コンポーネントの定義にちょっと戻りましょう。 テンプレートの最後の要素 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "<ng-content select=\"footer\"></ng-content>",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " に気づきましたか？ ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "ng-content",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " を使うと、そのコンポーネントの開始タグと終了タグの間に置かれたcontentを、テンプレートの中に投影することができます！ ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "ng-content",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " に与えている ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "select",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " 属性はCSSのセレクタで、contentの中から投影するものを選ぶことができます。 上の例では ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "footer",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " が ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "todo-app",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " コンポーネントの一番下に挿入されます。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "もし ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "select",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " 要素を省いた場合は、content全体が投影されます。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "<todo-input>",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " と ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "<todo>",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " の2つのコンポーネントについては今回の話には関係ないので実装部分を省略していますが、 このアプリケーションの完成形はこんな感じになります。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "image",
      "url": "http://blog.mgechev.com/images/todo-app-sample.gif",
      "caption": ""
    },
    {
      "type": "heading",
      "level": 2,
      "text": [
        {
          "type": "text",
          "text": "ViewChildren と ContentChildren",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "ここまでは簡単でしたね！さて、ようやくView ChildrenとContent Childrenという概念を定義する準備ができました。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "その定義とは、「テンプレートの中に配置された子要素を ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "View Children",
          "annotations": {
            "italic": true
          }
        },
        {
          "type": "text",
          "text": " と呼ぶ」、 そして「開始タグと終了タグの間に置かれた要素を ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "Content Children",
          "annotations": {
            "italic": true
          }
        },
        {
          "type": "text",
          "text": " と呼ぶ」です。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "つまり、",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "todo-input",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " と ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "todo",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " の2つの要素は ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "todo-app",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " にとっての View Childrenであり、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "footer",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " はContent Childであるというわけです。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "heading",
      "level": 3,
      "text": [
        {
          "type": "text",
          "text": "子要素にアクセスする",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "ようやく本題に入れます！2種類の子要素にどうやってアクセスし、操作するのか、その方法を見ていきましょう！",
          "annotations": {}
        }
      ]
    },
    {
      "type": "heading",
      "level": 3,
      "text": [
        {
          "type": "text",
          "text": "View Childrenを使った例",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "Angular 2では次のプロパティデコレータを ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "angular2/core",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " パッケージで提供しています。：",
          "annotations": {}
        }
      ]
    },
    {
      "type": "bulleted_list",
      "items": [
        {
          "type": "bulleted_list_item",
          "text": [
            {
              "type": "text",
              "text": "@ViewChildren",
              "annotations": {
                "code": true
              }
            }
          ],
          "children": []
        },
        {
          "type": "bulleted_list_item",
          "text": [
            {
              "type": "text",
              "text": "@ViewChild",
              "annotations": {
                "code": true
              }
            }
          ],
          "children": []
        },
        {
          "type": "bulleted_list_item",
          "text": [
            {
              "type": "text",
              "text": "@ContentChildren",
              "annotations": {
                "code": true
              }
            }
          ],
          "children": []
        },
        {
          "type": "bulleted_list_item",
          "text": [
            {
              "type": "text",
              "text": "@ContentChild",
              "annotations": {
                "code": true
              }
            }
          ],
          "children": []
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "これは次のように使います。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "code",
      "language": "",
      "filename": "",
      "text": "import {ViewChild, ViewChildren, Component...} from 'angular2/core';\n\n// ...\n\n@Component({\n  selector: 'todo-app',\n  providers: [TodoList],\n  directives: [TodoCmp, TodoInputCmp],\n  template: `...`\n})\nclass TodoAppCmp {\n  @ViewChild(TodoInputCmp)\n  inputComponent: TodoInputCmp\n  \n  @ViewChildren(TodoCmp)\n  todoComponents: QueryList<TodoCmp>;\n\n  constructor(private todos: TodoList) {}\n  ngAfterViewInit() {\n    // available here\n  }\n}\n\n// ..."
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "上の例では、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "@ViewChildren",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " と ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "@ViewChild",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " を使っています。 プロパティをデコレートすると、要素をクエリできるようになります。 上の例だと、子コンポーネントである ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoInputCmp",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " を ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "@ViewChild",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": "で、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoCmp",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " を ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "@ViewChildren",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " でクエリしています。 2つのデコレータを使い分けている理由は、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoInputCmp",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " は1つしかないので ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "@ViewChild",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " を使えますが、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoCmp",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " は複数個が表示されるので ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "@ViewChildren",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " を使う必要があるからです。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "もう一つ重要なことは、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "inputComponent",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " と ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "todoComponents",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " の型です。 前者のプロパティの型は ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoInputCmp",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " になっています。 これはクエリした結果要素が見つからなければnullになり、見つかればそのコンポーネントのインスタンスが代入されます。 一方、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "todoComponents",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " プロパティの型は ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "QueryList<TodoCmp>",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " で、動的に増えたり減ったりする ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoCmp",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": "のインスタンスを扱えます。 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "QueryList",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " はObservableなコレクションなので、新しく追加されたり、要素が削除された時にはイベントを発生してくれます。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "AngularのDOMコンパイラは ",
          "annotations": {
            "bold": true
          }
        },
        {
          "type": "text",
          "text": "todo-app",
          "annotations": {
            "bold": true,
            "code": true
          }
        },
        {
          "type": "text",
          "text": " コンポーネントを先に初期化し、その後子要素を初期化します。",
          "annotations": {
            "bold": true
          }
        },
        {
          "type": "text",
          "text": " ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "つまり ",
          "annotations": {
            "bold": true
          }
        },
        {
          "type": "text",
          "text": "todo-app",
          "annotations": {
            "bold": true,
            "code": true
          }
        },
        {
          "type": "text",
          "text": " コンポーネントの初期化の間は ",
          "annotations": {
            "bold": true
          }
        },
        {
          "type": "text",
          "text": "inputComponent",
          "annotations": {
            "bold": true,
            "code": true
          }
        },
        {
          "type": "text",
          "text": " も ",
          "annotations": {
            "bold": true
          }
        },
        {
          "type": "text",
          "text": "todoComponents",
          "annotations": {
            "bold": true,
            "code": true
          }
        },
        {
          "type": "text",
          "text": " もまだ初期化されていません",
          "annotations": {
            "bold": true
          }
        },
        {
          "type": "text",
          "text": " ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "これらは ",
          "annotations": {
            "bold": true
          }
        },
        {
          "type": "text",
          "text": "ngAfterCiewInit",
          "annotations": {
            "bold": true,
            "code": true
          }
        },
        {
          "type": "text",
          "text": " ライフサイクルフックのタイミングで使用可能になります",
          "annotations": {
            "bold": true
          }
        }
      ]
    },
    {
      "type": "heading",
      "level": 3,
      "text": [
        {
          "type": "text",
          "text": "Content Childrenにアクセスする",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "Content Childrenについてもほとんど同じルールが通用しますが、少しだけ違いがあります。 それを説明するために、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoAppCmp",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " を使う側のルートコンポーネントを見てみましょう。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "code",
      "language": "",
      "filename": "",
      "text": "@Component({\n  selector: 'footer',\n  template: '<ng-content></ng-content>'\n})\nclass Footer {}\n\n@Component(...)\nclass TodoAppCmp {...}\n\n@Component({\n  selector: 'app',\n  styles: [\n    'todo-app { margin-top: 20px; margin-left: 20px; }'\n  ],\n  template: `\n    <content>\n      <todo-app>\n        <footer>\n          <small>Yet another todo app!</small>\n        </footer>\n      </todo-app>\n    </content>\n  `,\n  directives: [TodoAppCmp, NgModel, Footer]\n})\nexport class AppCmp {}"
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "ここでは2つのコンポーネント ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "Footer",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " と ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "AppCmp",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " を定義しています。 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "Footer",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " は開始タグと終了タグの間に渡された要素をすべて投影します( ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "<footer>ここが表示されます</footer>",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " ) 一方、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "AppCmp",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " は ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoAppCmp",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " を使い、さらに ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "Footer",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " を開始タグと終了タグの間に渡しています。 つまり、これは我々の用語では ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "Footer",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " はContent Childであるといえます。これにアクセスするには次の例のようにします。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "code",
      "language": "",
      "filename": "",
      "text": "// ...\n@Component(...)\nclass TodoAppCmp {\n  @ContentChild(Footer)\n  footer: Footer;\n  \n  ngAfterContentInit() {\n    // this.footer is now with value set\n  }\n}\n// ..."
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "View ChildrenとContent Childrenの違いは、使っているデコレータとライフサイクルフックの種類だけです。 Content Childrenには ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "@ContentChild",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " または ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "@ContentChildren",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " デコレータを使い、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "ngAfterContentInit",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " ライフサイクルで使用可能になります。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "heading",
      "level": 2,
      "text": [
        {
          "type": "text",
          "text": "viewProviders",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " と ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "providers",
          "annotations": {
            "code": true
          }
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "もうほとんど説明は終わってしまいました！ 最後のステップは、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "providers",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " と ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "viewProviders",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " の違いを理解することです。 (もしあなたがAngular 2のDIのメカニズムを理解していなければ、まず ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "私の本",
          "href": "https://www.packtpub.com/web-development/switching-angular-2",
          "annotations": {}
        },
        {
          "type": "text",
          "text": " を読むといいでしょう)",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "さて、それでは ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoAppCmp",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " の宣言部分を覗いてみましょう。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "code",
      "language": "",
      "filename": "",
      "text": "class TodoList {\n  private todos: Todo[] = [];\n  add(todo: Todo) {}\n  remove(todo: Todo) {}\n  set(todo: Todo, index: number) {}\n  get(index: number) {}\n  getAll() {}\n}\n\n@Component({\n  // ...\n  viewProviders: [TodoList],\n  directives: [TodoCmp, TodoInputCmp],\n  // ...\n})\nclass TodoAppCmp {\n  constructor(private todos: TodoList) {}\n  // ...\n}"
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "@Component",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " デコレータの中で ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "viewProviders",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " プロパティがセットされ、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoList",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " サービスが渡されています。 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoList",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " サービスはすべてのTodoのアイテムを保持しているサービスです。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "TodoAppCmp",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " のコンストラクタでは ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoList",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " をインジェクトしていますが、 これは ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoAppCmp",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " コンポーネントの中で使われている他のディレクティブ(もちろんコンポーネントも)でもインジェクト可能です。 つまり、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoList",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " は次の場所からアクセス可能です",
          "annotations": {}
        }
      ]
    },
    {
      "type": "bulleted_list",
      "items": [
        {
          "type": "bulleted_list_item",
          "text": [
            {
              "type": "text",
              "text": "TodoAppCmp",
              "annotations": {}
            }
          ],
          "children": []
        },
        {
          "type": "bulleted_list_item",
          "text": [
            {
              "type": "text",
              "text": "TodoCmp",
              "annotations": {}
            }
          ],
          "children": []
        },
        {
          "type": "bulleted_list_item",
          "text": [
            {
              "type": "text",
              "text": "TodoInputCmp",
              "annotations": {}
            }
          ],
          "children": []
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "ところが、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "Footer",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " コンポーネントのコンストラクタでこのサービスをインジェクトしようとすると、次のようなエラーが表示されるでしょう。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "code",
      "language": "",
      "filename": "",
      "text": "EXCEPTION: No provider for TodoList! (Footer -> TodoList)"
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "これは ",
          "annotations": {
            "bold": true
          }
        },
        {
          "type": "text",
          "text": "viewProviders",
          "annotations": {
            "bold": true,
            "code": true
          }
        },
        {
          "type": "text",
          "text": " によって宣言されたプロバイダはそのコンポーネントとView Childrenにだけアクセス可能になるということです",
          "annotations": {
            "bold": true
          }
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "Footer",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " でも ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "TodoList",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " サービスにアクセスしたい場合は、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "viewProviders",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " から ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "providers",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " に変える必要があります。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "heading",
      "level": 3,
      "text": [
        {
          "type": "text",
          "text": "viewProviders",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " はいつ使うべき？",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "いったいどういう時に、Content Childrenからアクセスできないように ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "viewProviders",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " を使うべきなのでしょうか？ 仮にあなたがサードパーティのライブラリを作り、その中でインターナルなサービスを使うとします。 そのサービスはライブラリの内部的なAPIの一部で、他のユーザーからはアクセスさせたくないものです。 そのようなプライベートな依存性を ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "providers",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " を使って登録し、ライブラリで公開しているコンポーネントの中にユーザーがContent Childrenを渡すと、 その人はアクセスできてしまいます。 しかし、あなたが ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "viewProviders",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " を使えば、そのサービスは外からは使えなくなります。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "heading",
      "level": 2,
      "text": [
        {
          "type": "text",
          "text": "まとめ",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "この記事ではコンポーネントとディレクティブの合成の方法について解説しました。 また、View ChildrenとContent Childrenの違いと、それらにどうやってアクセスするのかについても紹介しました。",
          "annotations": {}
        }
      ]
    },
    {
      "type": "paragraph",
      "text": [
        {
          "type": "text",
          "text": "そして最後に、 ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "viewProviders",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " と ",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "providers",
          "annotations": {
            "code": true
          }
        },
        {
          "type": "text",
          "text": " の意味についても説明しました。 もしこのテーマにもっと興味がある場合は、私が書いている",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "Switching to Angular 2",
          "href": "https://www.packtpub.com/web-development/switching-angular-2",
          "annotations": {}
        },
        {
          "type": "text",
          "text": "を読むことをおすすめします！",
          "annotations": {}
        }
      ]
    }
  ]
}
