---
title: 'AngularのContent Projectionの基本'
date: '2020-02-10T00:00:00.000Z'
tags:
  - 'tech'
  - 'angular'
  - 'Web Components'
published: true
source: 'https://www.notion.so/Angular-Content-Projection-09047f7df09e48ecb004a98745ede141'
---

本稿では Angular コンポーネント間でビュー領域を受け渡しする **Content Projection** という概念と、その実装パターンについてあらためて解説する。

## Re-thinking about `&lt;ul&gt;`

さて、Angular の話に入る前にまずは HTML 標準の `&lt;ul&gt;` 要素について考えてみよう。 `&lt;ul&gt;` は言わずとしれた Unordered List のための HTML 要素だが、われわれが常日頃 `&lt;ul&gt;` を使うときは次のように HTML を書く。

```html
<ul>
  <li>Item 1</li>
  <li>Item 2</li>
</ul>
```

Angular の文脈において、開始タグと終了タグの間の`&lt;li&gt;` の位置にあるものは、 `&lt;ul&gt;` の **Content** と呼ばれる。そして、自身に与えられた Content を自身のビューの一部として投影することを **Content Projection** と呼ぶ。AngularJS の概念のなかでは transclusion とも呼ばれたが、今は Content Projection が一般的な語彙である。

HTML 標準要素は基本的にすべての要素が自動的に Content Projection を透過的におこなう。だからこそわれわれは `&lt;div&gt;` を重ねがけできるし、 `&lt;a&gt;`タグの中に`&lt;button&gt;`タグを置くこともできる。勘がいい読者は気づいているかもしれないが、 `&lt;li&gt;Item 1&lt;/li&gt;` における `Item 1` も TextNode の Content である。HTML と DOM は Content Projection によって成り立っていて、ほぼすべての HTML 標準要素は Content をそのまま投影する。そしてその投影のネスト構造にあわせた CSS セレクタを使ってスタイリングされている。

## Angular の Content Projection と Web Components

Angular に話を戻そう。Angular のコンポーネントは基本的に Web Components の概念を踏襲している。そのため、Angular のコンポーネントについて学ぶ上で Web Components の基本概念は踏まえておく必要がある。

Web Components の Custom Elements は HTML のカスタム要素を定義する機能である。カスタム要素は標準要素と違い、**自動的に Content Projection はおこなわれない**。特に Shadow DOM と組み合わせたカスタム要素は、スタンドアロンでカプセル化されたビューであるため、カプセル化の外からビューを与えて干渉することはカスタム要素側が許可しない限り不可能だ。 そして Shadow DOM では、自身の DOM ツリー内に `&lt;slot&gt;` という要素を宣言すると、その位置に Content が投影される。

[https://developer.mozilla.org/ja/docs/Web/HTML/Element/slot](https://developer.mozilla.org/ja/docs/Web/HTML/Element/slot) [https://developer.mozilla.org/ja/docs/Web/Web_Components/Using_templates_and_slots](https://developer.mozilla.org/ja/docs/Web/Web_Components/Using_templates_and_slots)

これと同様の概念を Angular のコンポーネントも備えていて、それが `&lt;ng-content&gt;` 疑似要素と、 `@ContentChild()` / `@ContentChildren()` 機能だ。 これらの概念は基本的に Angular 2.0.0 のリリース時から変わっておらず、Angular のコンポーネント機能の根幹を支えている概念である。

## Content Projection 101: `&lt;ng-content&gt;`

一番簡単でインスタントな Content Projection の方法は、Angular コンポーネントのテンプレートで `&lt;ng-content&gt;` 疑似要素を使う方法だ。

https://stackblitz.com/edit/ivy-argkah

このように `HelloComponent` が `&lt;ng-content&gt;` 疑似要素で Content Projection の準備をしていれば、親コンポーネントが Content を渡せば自動的にその位置に投影される。

```plaintext
@Component({
  selector: 'hello',
  template: `
  <h1>Hello <ng-content></ng-content></h1>
  `,
})
export class HelloComponent  {}
```

```html
<hello>World</hello>
```

`&lt;ng-content&gt;` は `select` 属性を使って任意の CSS セレクタにマッチした Content だけを抽出して投影することもできる。次のように `HelloComponent` のテンプレートを編集し、親コンポーネントから `&lt;span greeting&gt;` のように CSS セレクタにマッチする要素を渡すと、その要素だけを選択して投影する。

[https://stackblitz.com/edit/ivy-do5tyk](https://stackblitz.com/edit/ivy-do5tyk)

```html
<h1>
  <ng-content select="[name]"></ng-content>!
  <ng-content select="[greeting]"></ng-content>
</h1>
```

```html
<hello>
  <span greeting>Hello</span>
  <span name>World</span>
</hello>
```

このとき、`HelloComponent` にとって 2 種類の _子_ が生まれている。それが**View Child** と **Content Child** であり、Angular のなかでもとりわけ重要な概念である。

`&lt;h1&gt;` 要素は `HelloComponent` の **View Child** である。自身の **ビュー** の一部であり、自身の内部に閉じた本当の子要素である。 Content として渡された`World`は、 `HelloComponent` の **Content Child** である。DOM ツリー上は子要素として描画されるが、テンプレート上に存在するわけではなく Content として投影されている意味論上の子要素である。 これらは Angular のレンダリングシステム上で明確に区別されており、Angular の API の各所に **View** と **Content** の語彙の使い分けが見られるはずだ。 この基本概念を踏まえなければ、これより先の Content Projection の理解は難しい。

## Content Projection 201: `@ContentChild()` & `TemplateRef`

`&lt;ng-content&gt;` はテンプレートだけで完結するインスタントな方法だが、現在の Angular の仕様上いくつかの制約がある。

- `&lt;ng-content&gt;` は Content をテンプレート化できない。つまり同じ Content を繰り返し投影することができない
- `&lt;ng-content&gt;` はディレクティブクラスによる選択ができない。CSS セレクターによってのみ選択できる

そこで、より柔軟に Content を扱うための API として `@ContentChild()` API と `&lt;ng-template&gt;` API が存在する。

[https://angular.io/api/core/ContentChild](https://angular.io/api/core/ContentChild)

[https://angular.io/api/core/TemplateRef](https://angular.io/api/core/TemplateRef)

`@ContentChild()` デコレーターは、その引数の条件に一致する Content Child の参照をコンポーネント内に保持できる機能である。条件に使用できるのは

- ディレクティブ（コンポーネント）クラス
- テンプレート参照変数名

のいずれかである。 次の例では、親から与えられた `&lt;span&gt;` 要素を テンプレート参照変数 `#helloName` をキーにして取得している。

[https://stackblitz.com/edit/ivy-fngydx?file=src%2Fapp%2Fapp.component.html](https://stackblitz.com/edit/ivy-fngydx?file=src%2Fapp%2Fapp.component.html)

```plaintext
@Component({
  selector: 'hello',
  template: `
  <h1>
    Hello <ng-content></ng-content>
  </h1>
  `,
})
export class HelloComponent  {

  @ContentChild('helloName')
  content: ElementRef<any>;
}
```

```html
<hello>
  <span #helloName>World</span>
</hello>
```

しかしこのままでは `@ContentChild()` で取得した Content は投影できない。 `&lt;ng-content&gt;` は Content の取得と投影をセットでおこなうが、 `@ContentChild()` はあくまでも Content の参照を得る機能である。ここで得られる `content` は `&lt;span&gt;` タグの `ElementRef`になっているが、投影をおこなうためには渡された Content が投影可能な **Template** である必要がある。 Template は `&lt;ng-template&gt;` タグを使って宣言する。つまり、次のように親から `&lt;ng-template&gt;` 要素を Content として渡すことができる。

```html
<hello>
  <ng-template #helloName>
    <span>World</span>
  </ng-template>
</hello>
```

`HelloComponent` 側では、 `@ContentChild()` を使って受け取った Template の参照 `TemplateRef` を、 次のように`*ngTemplateOutlet` ディレクティブを使ってテンプレート中に投影する。

[https://stackblitz.com/edit/ivy-4y6nwq?file=src%2Fapp%2Fapp.component.html](https://stackblitz.com/edit/ivy-4y6nwq?file=src%2Fapp%2Fapp.component.html)

```plaintext
@Component({
  selector: "hello",
  template: `
    <h1>Hello <ng-container *ngTemplateOutlet="nameTemplate"></ng-container></h1>
  `,
})
export class HelloComponent {
  @ContentChild("helloName")
  nameTemplate: TemplateRef<any>;
}
```

Template は再利用可能なテンプレート部品なので、同じ Content を何度でも繰り返し表示できる。

[https://stackblitz.com/edit/ivy-rr1pwi?file=src/app/hello.component.ts](https://stackblitz.com/edit/ivy-rr1pwi?file=src/app/hello.component.ts)

```plaintext
@Component({
  selector: "hello",
  template: `
    <h1>Hello <ng-container *ngTemplateOutlet="nameTemplate"></ng-container></h1>
    <h2>Hello <ng-container *ngTemplateOutlet="nameTemplate"></ng-container></h2>
    <h3>Hello <ng-container *ngTemplateOutlet="nameTemplate"></ng-container></h3>
  `,
})
export class HelloComponent {
  @ContentChild("helloName")
  nameTemplate: TemplateRef<any>;
}
```

複雑な Content Projection が必要なときには、 `&lt;ng-content&gt;` ではなく `@ContentChild()` と `&lt;ng-template&gt;` を使ったアプローチを取る必要がある

## まとめ

- Angular のコンポーネントや Web Components では Content Projection は明示的に宣言する必要がある
- インスタントな Content Projection は `&lt;ng-content&gt;` だけで可能
- 再利用可能なテンプレートを受け取りたいときは `@ContentChild()` と `TemplateRef` を使った方法が必要
