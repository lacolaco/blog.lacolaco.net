---
title: 'Angular: Lightweight Injection Tokenという新しいテクニック'
date: '2020-07-29T00:00:00.000Z'
tags:
  - 'tech'
  - 'angular'
published: true
source: 'https://www.notion.so/Angular-Lightweight-Injection-Token-66159df0e34842f19a275319c346cdc3'
---

import LinkPreview from '../../components/features/LinkPreview.astro';

最近 Angular チームが発見し、Angular ライブラリの実装におけるパターンとして普及させようとしているのが、 **Lightweight Injection Token** というテクニックだ。これはこれまで不可能だった **コンポーネント(ディレクティブ)の Tree-Shaking** を可能にする。本稿ではこの新しいテクニックの概要、そして生まれた経緯や深く知るための参考リンクをまとめる。

なお、Lightweight Injection Token については公式ドキュメントでも解説される予定であるため、そちらを参照すればいい部分は省略する。

[Angular - Optimizing client app size with lightweight injection tokens](https://next.angular.io/guide/lightweight-injection-tokens)

## Lightweight Injection Token の概要

ひとことでいえば、「オプショナルな機能に関連する Injection Token として代替の軽量トークンを使う」ということである。Angular の DI を深く理解していればこれだけでピンと来るかもしれないが、具体例から概要をつかもう。

ある Angular ライブラリが、次のような使い方ができる `&lt;lib-card&gt;` コンポーネントを提供している。

```html
<lib-card> Hello World! </lib-card>
```

このコンポーネントは、Content として `&lt;lib-card-header&gt;` コンポーネントを配置すると、カードのヘッダーとして取り扱う **オプショナル** な機能があることをイメージしよう。

```html
<lib-card>
  <lib-card-header>Greeting Card</lib-card-header>
  Hello World!
</lib-card>
```

ライブラリ側はこのような使い方ができるコンポーネントを実装するとおおよそ次のようになるだろう。 `@ContentChild()` を使って `CardHeaderComponent` の参照を得る。ただしこのヘッダーを置くかどうかはユーザー次第なので、 `CardHeaderComponent|null` という形で null を許容することになる。

```plaintext
@Component({
  selector: 'lib-card-header',
  ...,
})
class CardHeaderComponent {}

@Component({
  selector: 'lib-card',
  ...,
})
class CardComponent {
  @ContentChild(CardHeaderComponent)
  header: CardHeaderComponent|null = null;
}
```

ここで問題になるのが、 `CardComponent` から `CardHeaderComponent` への参照の持ち方である。 `@ContentChild(CardHeaderComponent)` と `header: CardHeaderComponent|null` の 2 箇所で参照を持っているが、この 2 つは性質が異なる。

後者の `header: CardHeaderComponent|null` は、**型**としての参照である。この参照は TypeScript のコンパイル時型チェックにのみ用いられ、コンパイル後の JavaScript には残らないため問題にならない。

問題は前者の `@ContentChild(CardHeaderComponent)` だ。これは**値**としての参照であり、 `CardHeaderComponent` というクラスオブジェクトそのものを参照している。それが直接 `@ContentChild()` デコレーターに渡されているのだから、**ユーザーがヘッダーを使おうが使わまいが、この参照は実行時に残る**。

`@ViewChild()` や `@ContentChild()` の走査条件として使われるコンポーネント/ディレクティブのクラス参照はどうしても Tree-Shaking できず、これが Angular ライブラリを利用したときの**バンドルサイズの肥大化の原因**となる。

これを解決するためのアプローチが、Lightweight Injection Token だ。上記の例で `@ContentChild()` デコレーターに渡していたクラスを、次のように軽量なオブジェクトを利用した Injection Token に置き換える。

```plaintext
// Lightweight Injection Token
abstract class CardHeaderToken {}

@Component({
  selector: 'lib-card-header',
  providers: [
    {provide: CardHeaderToken, useExisting: CardHeaderComponent}
  ]
  ...,
})
class CardHeaderComponent extends CardHeaderToken {}

@Component({
  selector: 'lib-card',
  ...,
})
class CardComponent {
  @ContentChild(CardHeaderToken) header: CardHeaderToken|null = null;
}
```

まず `CardHeaderToken` 抽象クラスを作成し、 `CardHeaderComponent` をその具象クラスとする。そしてコンポーネントプロバイダーで `CardHeaderToken` に対して自身のクラスオブジェクトを提供する。 `CardComponent` ではトークンを `@ContentChild()`デコレーターの走査条件とする。

これにより、 `CardComponent` から直接の `CardHeaderComponent` への参照はなくなり、ライブラリのユーザーが `&lt;lib-card-header&gt;` コンポーネントを呼び出したときだけ `CardHeaderToken` に対して `CardHeaderComponent` クラスのインスタンスが提供されることになる。

`@ContentChild()` や `@ViewChild()` の引数として DI トークンを渡せるようになるのがバージョン 10.1.0 からなので、このアプローチが取れるのは**バージョン 10.1.0 以降**になる（ `as any` で突破する手法はあるが）。

[feat(core): support injection token as predicate in queries (#37506) · angular/angular@97dc85b](https://github.com/angular/angular/commit/97dc85ba5e4eb6cfa741908a04cfccb1459cec9b)

## なぜ今なのか、これまでの経緯

この問題は昔からずっと存在したが、実はバージョン 8 まではそれほど重大な問題ではなかった。なぜかというとバージョン 8 以前、つまり Ivy 以前 (ViewEngine, VE) は AOT コンパイルによってテンプレートコンパイルされた結果の生成コードが、もとのコンポーネントとは別のクラス実体をもっていたからだ。

ViewEngine では `CardComponent` クラスのデコレーターとそのメタデータをもとに `CardComponentNgFactory` クラスが生成される。そして、JavaScript としてコードサイズが大きいのはほとんどの場合 NgFactory 側である。

つまり上記の例でいえば、 たとえ `CardComponentNgFactory` クラスが `CardHeaderComponent` への参照を持っていたとしても、`CardHeaderComponent` そのものが大きくないために問題にならなかったのだ。サイズが大きいのは `CardHeaderComponenNgFactory` のほうで、NgFactory は テンプレート中で `&lt;lib-card-header&gt;` を使わない限り参照されないため、不完全ではあるが Tree-Shaking できていたのが ViewEngine 方式だった。

バージョン 9 からデフォルトになった Ivy 方式の AOT コンパイルは、生成コードを **もとのクラスの静的フィールドとして合成する**。よって AOT コンパイルすると `CardHeaderComponent` そのもののサイズが大きくなり、 `CardComponent` に巻き込まれて一緒にバンドルされるサイズが顕著に大きくなる。いままで行なわれていた生成コードの Tree-Shaking が Ivy によりなくなってしまった。

つまり、Lightweight Injection Token は ViewEngine 時代には顕在化していなかったが Ivy によってクリティカルになった問題を解決するために編み出された、**Ivy 時代の Angualr ライブラリ実装パターン**である。

もっともポピュラーな Angular のコンポーネントライブラリである Angular Material ではバージョン 9 リリース時からバンドルサイズの増加が報告されており、その解消の過程で Angular チームが辿り着いた答えである。現在 Angular Components チームは Angular Material の各コンポーネントを Lightweight Injection Token パターンに置き換える作業を進めている。

<LinkPreview src="https://github.com/angular/components/issues/19610" />

[Use light-weight injection pattern for optimized tree-shaking/bundle size · Issue #19576 · angular/components](https://github.com/angular/components/issues/19576)

## コンポーネント以外の Lightweight Injection Token

ところで、 `@ContentChild()` などの走査条件でなくとも、通常の DI の中でもオプショナルなものについては Lightweight Injection Token パターンを使うべきである。 `@Optional()` を使っていてもそのトークンの参照は残るため Tree-Shaking はできない。コンストラクタ DI では型注釈部分にしか参照がないためコンパイルすれば消えそうに見えるが、コンストラクタ引数の型注釈は AOT コンパイル時に自動的に `@Inject()` デコレーターに変換されるため、実体参照をもつのである。つまりこれも `@ContentChild()` と全く同じ構造であり、同じ問題をもちうる。ライブラリ作者であればオプショナルなプロバイダーのトークンは可能な限り軽量にしておくべきだろう。

```plaintext
class MyComponent {
  constructor(@Optional() srv: OptionalService) {}
}

// Same
class MyComponent {
  constructor(@Optional() @Inject(OptionalService) srv: OptionalService) {}
}
```

ちなみにコンポーネントの Lightweight Injection Token として `InjectionToken` オブジェクトを使うこともできるはずだ。公式ドキュメントでは抽象クラスの例が紹介されているが、どちらが定着するかは今後のコミュニティでの受け入れられ方次第だろう。ただ、トークンの抽象クラスとコンポーネントクラスを継承関係にするとそのままコンポーネントの API 定義として利用もできるため、おそらくは抽象クラスのほうが便利な場面は多そうだ。

```plaintext
const CardHeaderToken
  = new InjectionToken<CardHeaderComponent>("CardHeaderComponent");
```

[https://angular.io/guide/dependency-injection-providers#non-class-dependencies](https://angular.io/guide/dependency-injection-providers#non-class-dependencies)

## 参考リンク

以下に参考リンクをまとめる。

- Misko Hevery による Design Doc [https://hackmd.io/@mhevery/SyqDjUlrU](https://hackmd.io/@mhevery/SyqDjUlrU)
- 公式ドキュメントへの追加 PR [https://github.com/angular/angular/pull/36144](https://github.com/angular/angular/pull/36144)
- Angular Material の Issue [https://github.com/angular/components/issues/19576](https://github.com/angular/components/issues/19576)
